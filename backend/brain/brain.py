# -*- coding: utf-8 -*-
"""brainbrainbrain.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Q4pso8Qcxt6agj1AJm71DLkSpPAIFQdb
"""

import sys
sys.path.insert(0, '..')
import serveUnit
import json

import opendatasets as od
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Tensorflow
import tensorflow as tf
from tensorflow.keras import callbacks
from tensorflow.keras import Sequential
from tensorflow.keras.layers import Dense
from tensorflow.keras.layers import Dropout
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import f1_score,precision_score,recall_score
from tensorflow import keras
import glob
import cv2
import os



od.download("https://www.kaggle.com/masoudnickparvar/brain-tumor-mri-dataset")

#"8a1e2a3f49c4ab0c2b9edf761487141f"

features = []
labels = []

classes = ["glioma", "meningioma", "notumor", "pituitary"]

for i in range(len(classes)):
    file_list = glob.glob("./brain-tumor-mri-dataset/Training/" + classes[i] + "/*.jpg")
    for item in range(len(file_list)):
        features.append(file_list[item])
        labels.append([i])

print(features)
print("Dataset Feature size : ",len(features))
print("Dataset labels size : ",len(labels))

x_train = []
y_train = []
x_test = []
y_test = []

for i in range(len(features)):
    img = cv2.imread(features[i],cv2.IMREAD_COLOR)
    if (str(img.shape) == "(512, 512, 3)"):
      x_train.append(img)
      x_train[-1] = np.reshape(x_train[-1],[512,512,3])
      y_train.append(labels[i])

print(len(x_train))
print(len(y_train))

x_train,x_test,y_train,y_test = train_test_split(x_train,y_train,test_size=0.3)
print("Train data : ",len(x_train),len(y_train))
print("Validation data : ",len(x_test),len(y_test))

model = Sequential()

model.add(keras.layers.Conv2D(32,(3,3),activation="relu",padding="same",input_shape=(512,512,3)))
model.add(keras.layers.Conv2D(32,(3,3),activation="relu",padding="same"))
model.add(keras.layers.MaxPooling2D(3,3))

model.add(keras.layers.Conv2D(64,(3,3),activation="relu",padding="same"))
model.add(keras.layers.Conv2D(64,(3,3),activation="relu",padding="same"))
model.add(keras.layers.MaxPooling2D(3,3))

model.add(keras.layers.Conv2D(128,(3,3),activation="relu",padding="same"))
model.add(keras.layers.Conv2D(128,(3,3),activation="relu",padding="same"))
model.add(keras.layers.MaxPooling2D(3,3))

model.add(keras.layers.Conv2D(256,(3,3),activation="relu",padding="same"))
model.add(keras.layers.Conv2D(256,(3,3),activation="relu",padding="same"))

model.add(keras.layers.Flatten())

model.add(keras.layers.Dense(512,activation="relu"))
model.add(keras.layers.Dropout(0.5))

model.add(keras.layers.Dense(29,activation="softmax"))

opt = keras.optimizers.Adam(learning_rate=0.0001)
model.compile(optimizer=opt,loss="sparse_categorical_crossentropy",metrics=['accuracy'])
model.summary()

x_train = np.array(x_train)
y_train = np.array(y_train) 
x_test = np.array(x_test)
y_test = np.array(y_test)

if (os.path.exists("./lastModel.h5")):
  print("Found cached model")
  model = keras.models.load_model("./lastModel.h5")
else:
  history = model.fit(x_train,
          y_train,
          epochs=4,
          validation_data = (x_test,y_test))

model.save("lastModel.h5")

y_pred = np.argmax(model.predict(x_test),1)
print("Precision : {:.2f} %".format(precision_score(y_pred,y_test,average='macro')))
print("Recall    : {:.2f} %".format(precision_score(y_pred,y_test,average='macro')))
print("F1 Score  : {:.2f} %".format(precision_score(y_pred,y_test,average='macro')))

incorrect = []

def getIncorrect(model, image, correct_label, index):
  prediction = model.predict(np.array([image]))
  predicted_class = classes[np.argmax(prediction)]
  if classes[correct_label] != predicted_class:
    incorrect.append(index)

for i in range(1187):
  image = x_test[i]
  label = y_test[i][0]
  getIncorrect(model, image, label, i)

print(incorrect)

len(incorrect)

def predict(model, image, correct_label):
  prediction = model.predict(np.array([image]))
  predicted_class = classes[np.argmax(prediction)]
  show_image(image, classes[correct_label], predicted_class)


def show_image(img, label, guess):
  plt.figure()
  plt.imshow(img, cmap=plt.cm.binary)
  plt.colorbar()
  plt.grid(False)
  plt.show()
  print("Expected: " + label)
  print("Guess: " + guess)

def get_number():
  while True:
    num = input('Pick a number between 0 and %s: ' % len(x_test))
    if num.isdigit():
      num = int(num)
      if 0 <= num <= len(x_test):
        return num
    else:
      print("Try again...")


#num = get_number()
#image = x_test[num]
#label = y_test[num][0]
#predict(model, image, label)

def classify(image):
    y_pred = model.predict(np.array([image]))
    return json.dumps(y_pred[0].tolist())

serveUnit.subscribe(classify)

serveUnit.start(port=5001)